#!/bin/bash

standalone_prog=fe

# If we're on a remote display, don't use emacsclient.
# There must be a better test than this...
if [ -n "$SSH_TTY" ]; then
    $standalone_prog "$@"
    exit $?
fi

# Save the current winid so we know what to switch back to from emacs.
client_winid=`current-winid`

# Switch to emacs and wait for editing to be completed.

debug () {
    :
    echo "$*" >&2
}

emacs_winids=( $(wmctrl -lpx | awk '$4 ~ /emacs/ { print $1 }') )
if [ "${#emacs_winids[*]}" -eq 1 ]; then
    wmctrl -ia $emacs_winids[1]
elif [ "${#emacs_winids[*]}" -gt 1 ]; then
    current_desktop=`current-desktop`
    debug "More than one emacs frame; will prefer one on desktop $current_desktop" >&2
    emacs_winid=$( wmctrl -lpx | \
                   awk '$4 ~ /emacs/ && $2 == '$current_desktop' { print $1 }' )
    if [ -n "$emacs_winid" ]; then
        debug "winid of emacs on current desktop is $emacs_winid"
        wmctrl -ia $emacs_winid

        # The problem here is that emacsclient doesn't tell emacs
        # server which frame to open the new buffer in.  FIXME: tweak
        # `server-switch-hook' to do this somehow (env variable?)
        # http://emacs-fu.blogspot.com/2008/12/opening-emacsclient-windows-on-current.html
    else
        debug "No emacs on current desktop; picking any one"
        wmctrl -xa emacs
    fi
else
    echo "ERROR: no emacs windows found" >&2
fi

emacsclient -a $standalone_prog "$@"

# Switch back to window from which emacsclient was invoked.
wmctrl -ia $client_winid
