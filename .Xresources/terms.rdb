/*
  WARNING!  This file should be used with my custom xrdb-cpp preprocessor,
  via:
         xrdb -cpp xrdb-cpp
 
  It should also be included via `all.rdb', which first loads
  `defines.rdb'.
*/

!------------------------------------------------------------
!
! Appearance

! {{{ foreground/background

#ifdef BLACK_BG_XTERMS

#define TERM_FG rgb:bb/bb/bb
#define TERM_BG black

#define MENU_FG white
#define MENU_BG black

#else

#define TERM_FG black
#define TERM_BG rgb:ee/ee/ee

#define MENU_FG black
#define MENU_BG rgb:ee/ee/ee

#endif

XTerm*background:   TERM_BG
xterm*background:   TERM_BG
nxterm*background:  TERM_BG
Rxvt*background:    TERM_BG

XTerm*foreground:   TERM_FG
xterm*foreground:   TERM_FG
nxterm*foreground:  TERM_FG
Rxvt*foreground:    TERM_FG

! SimpleMenu is the type for all 3 menus (mainMenu, vtMenu, fontMenu)
xterm*SimpleMenu*background:  MENU_BG
nxterm*SimpleMenu*background: MENU_BG
xterm*SimpleMenu*foreground:  MENU_FG
nxterm*SimpleMenu*foreground: MENU_FG

! }}}
! {{{ bold/underline colours

! Use color or bold/underline for bold/underline?
*xterm*colorBDMode: on
*xterm*colorULMode: on

xterm*boldMode: false

#ifdef BLACK_BG_XTERMS

*VT100*colorBD: white
*VT100*colorUL: RGB:e0/e0/33

#else

*VT100*colorBD: black
*VT100*colorUL: blue

#endif

! }}}
! {{{ other colours

*xterm*color0: rgb:00/00/00
*xterm*color1: rgb:aa/00/00
*xterm*color2: rgb:00/88/00
*xterm*color3: rgb:aa/55/22
*xterm*color4: rgb:10/00/b6
*xterm*color5: rgb:aa/00/aa
!*xterm*color6: rgb:00/aa aa
*xterm*color6: rgb:79/ae/a6
*xterm*color7: rgb:e0/e0/e0
*xterm*color8: rgb:55/55/55
*xterm*color9: rgb:ff/44/44
!*xterm*color10: rgb:44/ff/44
*xterm*color10: rgb:9e/db/96
!*xterm*color11: rgb:ff/ff/44
*xterm*color11: rgb:f7/ff/a6
!*xterm*color12: rgb:44/44/ff
*xterm*color12: rgb:51/55/c8
*xterm*color13: rgb:ff/44/ff
!*xterm*color14: rgb:44/ff/ff
*xterm*color14: rgb:be/eb/f4
*xterm*color15: rgb:ff/ff/ff

! }}}
! {{{ fonts

! xrdb-cpp needs to be in the $PATH, then
!        xrdb -cpp xrdb-cpp
! will substitute two @ signs for newlines.

#define FontAndLabel(fontNum,fontName,label) \
xterm*VT100*font##fontNum:           fontName@@\
xterm*fontMenu*font##fontNum*Label:  label (fontName)@@\
nxterm*VT100*font##fontNum:          fontName@@\
nxterm*fontMenu*font##fontNum*Label: label (fontName)

#ifdef LARGE_SCREEN
*SimpleMenu*font: *helvetica*r*normal*12*

! Note: the default font is automatically inserted into the order
! according to its size.  That means we effectively have 7 font slots
! to play around with. 
xterm*font:  9x15
nxterm*font: 9x15

FontAndLabel(  1, nil2 ,      Unreadable)
!F!ontAndLabel(?, 5x7  ,      Micro)
!F!ontAndLabel(?, 5x8  ,      5x8)
!F!ontAndLabel(?, 6x10 ,      6x10)
FontAndLabel(  2, nexus,      nexus)
FontAndLabel(  3, smoothansi, smoothansi)
!F!ontAndLabel(?, kates,      kates)
!F!ontAndLabel(?, fixed,      fixed)
!F!ontAndLabel(?, 9x15,       9x15)   <--- default
FontAndLabel  (4, fkp,        fkp)
FontAndLabel  (5, 10x20,      10x20)
!F!ontAndLabel(?, vga11x19,   vga11x19)
FontAndLabel  (6, 12x24,      12x24)

#else

*SimpleMenu*font: *helvetica*r*normal*10*

xterm*font:  smoothansi
nxterm*font: smoothansi

FontAndLabel(  1, nil2 ,      Unreadable)
FontAndLabel(  2, 5x7  ,      Micro)
!F!ontAndLabel(?, 5x8  ,      5x8)
!F!ontAndLabel(?, 6x10 ,      6x10)
FontAndLabel(  3, nexus,      nexus)
!F!ontAndLabel(4, smoothansi, smoothansi)  <--- default
!F!ontAndLabel(?, kates,      kates)
!F!ontAndLabel(?, fixed,      fixed)
FontAndLabel(  4, 9x15,       9x15)
FontAndLabel  (5, fkp,        fkp)
FontAndLabel  (6, 10x20,      10x20)
!F!ontAndLabel(?, vga11x19,   vga11x19)
!F!ontAndLabel(?, 12x24,      12x24)

#endif

! }}}
! {{{ cursor

!#define CURSORCOLOR blue
#define CURSORCOLOR coral

XTerm*cursorColor:  CURSORCOLOR
nxterm*cursorColor: CURSORCOLOR

XTerm*cursorBlink:  true
nxterm*cursorBlink: true

! }}}
! {{{ pointer shape?

nxterm*Cursor: xterm

! }}}
! {{{ geometry

! Could ifdef on LARGE_SCREEN here
xterm.vt100.geometry: 92x40

! }}}
! {{{ title bar

xterm*titleBar:     false
nxterm*titleBar:    false

! }}}

!------------------------------------------------------------
!
! Behaviour

! {{{ scrolling

XTerm*saveLines:    1500
nxterm*saveLines:   1500
rxvt*saveLines:     1500

XTerm*scrollBar:    false
nxterm*scrollBar:   false
xterm*rightScrollBar: true

*scrollTtyOutput:   False
*scrollKey:     True
Scrollbar.JumpCursor:   True

xterm*VT100.JumpScroll:  true
nxterm*VT100.JumpScroll: true
XTerm.VT100.JumpScroll: true

! }}}
! {{{ key and mouse translations

/*
  Good reference here:
    http://www.in-ulm.de/~mascheck/X11/xterm/XTerm
  
  From
  http://moat.nlanr.net/Software/OC3mon/DOSCoraldist19980317/REMCTL/XDEFAULT.UNX
  :-
 
    in case you are wondering, magic words like 
    "Prior" and "BackSpace" are all listed in 
    	/usr/local/X11R6/include/X11/keysymdef.h
    with "XK_" in front of the name you can use here
 
    boy, is it frustrating to try guessing 'em!
 
    apparently, tilde in front of a shift means "not this shift"
    and exclaimation point in front of a shift means "just this shift"
 
    but the ~Shift somehow doesn't work on IRIX 6.3 X display
    in front of the lines that define ctrl-alt-L and ctrl-alt-X,
    even though it works fine for ctrl-alt-delete, so you need
    to take "~Shift" off the front of those definitions (which means
    that shift-ctrl-alt-L will have the same definition as ctrl-alt-L)
    if you live in that world
 
  In rxvt, Ctrl-Shift-Prior/Next is a bug which needs to be patched:
 
  http://lists.debian.org/debian-qa-packages/2005/10/msg00112.html
  http://bugs.donarmstrong.com/cgi-bin/bugreport.cgi?bug=226386
  TODO: Check http://sourceforge.net/projects/rxvt
*/

#define XTERM_DEFAULT_TRANSLATIONS \n\
               None <Key> BackSpace:     string(0x7F)\n\
 !Meta              <Key> BackSpace:     string(0x1b) string(0x7F)\n\
               None <Key> Delete:        string(0x04)\n\
               None <Key> Home:          string(0x1b) string("[1~")\n\
               None <Key> End:           string(0x1b) string("[4~")\n\
\
               None <Key> Prior:         string(0x1b) string("[5~")\n\
               None <Key> Next:          string(0x1b) string("[6~")\n\
             !Shift <Key> Prior:         scroll-back(1,halfpage)\n\
             !Shift <Key> Next:          scroll-forw(1,halfpage)\n\
       !Ctrl        <Key> Prior:         string(0x1b) string("[5\^")\n\
       !Ctrl        <Key> Next:          string(0x1b) string("[6\^")\n\
        Ctrl  Shift <Key> Prior:         string(0x1b) string("[5@")\n\
        Ctrl  Shift <Key> Next:          string(0x1b) string("[6@")\n\
  Meta  Ctrl        <Key> Prior:         string(0x1b) string("[5@")\n\
  Meta  Ctrl        <Key> Next:          string(0x1b) string("[6@")\n\
 !Meta              <Key> Prior:         string(0x1b) string("[5@")\n\
 !Meta              <Key> Next:          string(0x1b) string("[6@")\n\
\
                    <Btn4Down>,<Btn4Up>: scroll-back(1,halfpage)\n\
                    <Btn5Down>,<Btn5Up>: scroll-forw(1,halfpage)\n\
             !Shift <Btn4Down>,<Btn4Up>: scroll-back(1,line)\n\
             !Shift <Btn5Down>,<Btn5Up>: scroll-forw(1,line)\n\
       !Ctrl        <Btn4Down>,<Btn4Up>: scroll-back(1,page)\n\
       !Ctrl        <Btn5Down>,<Btn5Up>: scroll-forw(1,page)\n\
\
  Meta  Ctrl        <Key><:              smaller-vt-font()\n\
  Meta  Ctrl        <Key>>:              larger-vt-font()\n\
       !Ctrl        <Key>;:              string(0x03) string("E;")

  dabbrev-expand not supported for some reason
   Meta  Ctrl        <Key>/:              dabbrev-expand()

XTerm.vt100.translations: #override XTERM_DEFAULT_TRANSLATIONS
xterm.vt100.translations: #override XTERM_DEFAULT_TRANSLATIONS

/*
  In the scrollbar we map buttons 5 & 4 to 1 and 2 otherwise, core
  dump.  This will move proportionally to cursor position, but we
  don't know how to program the same exact behavior as in the text
  widget.
 */
XTerm.vt100.Scrollbar.translations: #override\n\
     <Btn5Down>: StartScroll(Forward)\n\
     <Btn4Down>: StartScroll(Backward)\n\

xterm*ttyModes: erase ^?

! }}}
! {{{ meta key

*eightBitInput: false
*EightBitInput: false
remotexterm*eightBitInput:  false
XTerm.VT100.EightBitInput:      false

! }}}

! {{{ bell

xterm*visualBell:   true
nxterm*visualBell:  true
!XTerm*visualBell:       true

! }}}
! {{{ terminal type

xterm*termName:          xterm-color
nxterm*termName:         xterm-color

! }}}

! {{{ selection

! Gotta have this one to trim trailing whitespace.
xterm*trimSelection: true

! Include newlines when selection includes end of line
! (e.g. via triple-click).
xterm*cutNewline: true

// Don't select entire line from beginning when triple-clicking.
xterm*cutToBeginningOfLine: false

! From: http://www.leidinger.net/X/xresources/app-defaults/XTerm_mascheck

! Which characters are considered to build a _single_ word for Cut&Paste?
! Every ascii-value gets mapped to another (arbitrary), already 'valid'
! character  with a colon.
! Here ascii 48 ("0") is the reference. See the manpage.
!
! I don't want these to separate 'words':   ! # $ % + - . / @ ~
XTerm.VT100.charClass: 33:48,35-37:48,43:48,45-47:48,64:48,126:48

! Reminder:
!   !    "    #    $    %    &    '    (    )    *    +    ,    -    .    / 
!   33,  34,  35,  36,  37,  38,  39,  40,  41,  42,  43,  44,  45,  46,  47,
!   @         [    \    ]    ^    _    `    {    |    }    ~  
!   64,       91,  92,  93,  94,  48,  96,  123, 124, 125, 126,

! Wether this works also with _wrapped_ selections, depends on
!  - the terminal emulator:  Neither MIT X11R5/6 nor Suns openwin xterm
!    know about that.  Use the 'xfree xterm' or 'rxvt'.  Both compile on
!    all major platforms.
!  - It only works if xterm is wrapping the line itself (if so is not
!    always really obvious for the user).
!  - Among the different vi's, vim actually supports this with a
!    clever and hackish trick (see screen.c):
!
!    But first: vim inspects the _name_ of the value of TERM.
!    This must be similar to 'xterm' (like xterm-color).
!    The terminfo entry _itself_ doesn't matter here
!    (e.g.: 'xterm' and 'vs100' are the same entry, but with
!     the latter it doesn't work).
!
!    If vim has to wrap a word, it appends a space at the first part,
!    this space will be wrapped by xterm.  vim in turn then positions
!    the cursor again at the _beginning_ of this next line. Thus, the
!    space is not visible. xterm now believes that the two lines are
!    actually a single one--as xterm _did_ some wrapping...

! Here comes a simple test for a                                   'wrapped_selection' (using an 80 chars wide terminal).
! Double click shall select the _whole_ word.

! }}}
! {{{ AutoWrap

xterm*VT100.AutoWrap:    true
nxterm*VT100.AutoWrap:   true
XTerm.VT100.AutoWrap:   true

! }}}
! {{{ reverseWrap

! what is this?
xterm*reverseWrap:  true
nxterm*reverseWrap: true
XTerm.VT100.ReverseWrap:        true

! }}}

! {{{ locale stuff

! *numeric:           C
! *displayLang:       C
! *basicLocale:       C
! *timeFormat:        C
! *inputLang:         C

! }}}

